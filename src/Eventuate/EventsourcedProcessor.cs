#region copyright
// -----------------------------------------------------------------------
//  <copyright file="EventsourcedProcessor.cs" company="Bartosz Sypytkowski">
//      Copyright (C) 2015-2019 Red Bull Media House GmbH <http://www.redbullmediahouse.com>
//      Copyright (C) 2019-2019 Bartosz Sypytkowski <b.sypytkowski@gmail.com>
//  </copyright>
// -----------------------------------------------------------------------
#endregion

using Akka.Actor;
using Akka.Configuration;
using Akka.Event;
using Eventuate.ReplicationProtocol;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Eventuate
{
    internal sealed class EventsourcedProcessorSettings
    {
        public EventsourcedProcessorSettings(Config config) : this(
            readTimeout: config.GetTimeSpan("eventuate.log.read-timeout", TimeSpan.FromSeconds(10)),
            writeTimeout: config.GetTimeSpan("eventuate.log.write-timeout", TimeSpan.FromSeconds(10)),
            writeBatchSize: config.GetInt("eventuate.log.write-batch-size", 64))
        {
        }

        public EventsourcedProcessorSettings(TimeSpan readTimeout, TimeSpan writeTimeout, int writeBatchSize)
        {
            ReadTimeout = readTimeout;
            WriteTimeout = writeTimeout;
            WriteBatchSize = writeBatchSize;
        }

        public TimeSpan ReadTimeout { get; }
        public TimeSpan WriteTimeout { get; }
        public int WriteBatchSize { get; }
    }

    /// <summary>
    /// An <see cref="EventsourcedWriter{TRead, TWrite}"/> that writes processed events to a <see cref="TargetEventLog"/>. <see cref="EventsourcedProcessor"/>
    /// is an idempotent writer that guarantees that no duplicates are ever written to the target event log,
    /// also under failure conditions. Hence, applications don't need to take extra care about idempotency.
    /// Processed events are those returned by <see cref="ProcessEvent"/>, an application-defined event handler that is
    /// invoked with events from the source <see cref="EventsourcedView.EventLog"/>.
    /// 
    /// During initialization, a processor reads the processing progress from the target event log. The timeout
    /// for this read operation can be configured with the `eventuate.log.read-timeout` parameter for all
    /// event-sourced processors or defined on a per class or instance basis by overriding `readTimeout`. The timeout
    /// for write operations to the target log can be configured with the `eventuate.log.write-timeout` parameter
    /// for all event-sourced processors or defined on a per class or instance basis by overriding `writeTimeout`.
    /// 
    /// An <see cref="EventsourcedProcessor"/> is a stateless processor i.e. in-memory state created from source events can
    /// not be recovered. An application that needs stateful event processing should use <see cref="StatefulProcessor"/>
    /// instead.
    /// 
    /// An <see cref="EventsourcedProcessor"/> processor writes events with vector timestamps set to source event vector timestamp.
    /// In other words, it does not modify event vector timestamps.
    /// 
    /// The source event log and the target event log of an <see cref="EventsourcedProcessor"/> must be different. Writing
    /// processed events back to the source event log has no effect.
    /// </summary>
    /// <seealso cref="StatefulProcessor"/>
    public abstract class EventsourcedProcessor : EventsourcedWriter<long, long>
    {
        private readonly EventsourcedProcessorSettings settings;
        private ImmutableArray<IReadOnlyCollection<DurableEvent>> processedEvents = ImmutableArray<IReadOnlyCollection<DurableEvent>>.Empty;
        private long processingProgress = 0L;

        protected EventsourcedProcessor()
        {
            this.settings = new EventsourcedProcessorSettings(Context.System.Settings.Config);
        }

        /// <summary>
        /// This processor's target event log.
        /// </summary>
        public abstract IActorRef TargetEventLog { get; }

        /// <summary>
        /// This processor's event handler. It may generate zero or more processed events per source event.
        /// </summary>
        public abstract IEnumerable<object> ProcessEvent(object domainEvent);

        /// <summary>
        /// Override to allow post-processing of DurableEvent instances wrapping events generated by <see cref="ProcessEvent(object)"/>.
        /// 
        /// Amongst other things, this can e.g. be used to set different or additional aggregate IDs for custom routing
        /// destinations (which by default take the same routing destinations as the original event that was processed).
        /// </summary>
        protected virtual DurableEvent PostProcessDurableEvent(DurableEvent e) => e;

        /// <summary>
        /// Collects processed events generated by <see cref="ProcessEvent(object)"/>.
        /// </summary>
        protected sealed override bool OnEvent(object message)
        {
            var currentProcessedEvents = ProcessEvent(message);
            if (LastSequenceNr > processingProgress)
            {
                var p = currentProcessedEvents
                    .Select(e => PostProcessDurableEvent(CreateEvent(e, LastHandledEvent.CustomDestinationAggregateIds)))
                    .ToArray();

                this.processedEvents = this.processedEvents.Add(p);
            }
            return true;
        }

        /// <summary>
        /// Asynchronously writes processed events that have been collected since the last write together
        /// with the current processing progress. If the number of processed events since the last write
        /// is greater than the configured `eventuate.log.write-batch-size` multiple batches with a size
        /// less than or equal to `eventuate.log.write-batch-size` will be written sequentially. When
        /// splitting into multiple batches it is guaranteed that the processing result of a single event
        /// is part of the same batch i.e. it is guaranteed that the processing result of a single event
        /// is written atomically. If the processing result of a single event is larger than
        /// `eventuate.log.write-batch-size`, `write` write does not split that batch into smaller batches.
        /// </summary>
        public sealed override Task<long> Write()
        {
            //WARNING: don't change that into async await - if you do, `this.processedEvents`
            //may end up being accessed concurrently from `this.OnEvent` running on another thread
            if (LastSequenceNr > processingProgress)
            {
                var task = WriteBatches(processedEvents, processingProgress, LastSequenceNr);
                this.processedEvents = ImmutableArray<IReadOnlyCollection<DurableEvent>>.Empty;
                return task;
            }
            else return Task.FromResult(processingProgress);
        }

        /// <summary>
        /// Asynchronously reads the processing progress from the target event log.
        /// </summary>
        public override async Task<long> Read()
        {
            var result = await TargetEventLog.Ask(new GetReplicationProgress(this.Id), timeout: ReadTimeout);
            switch (result)
            {
                case GetReplicationProgressSuccess s: return s.StoredReplicationProgress;
                case GetReplicationProgressFailure f: throw f.Cause;
                default: throw new NotSupportedException($"Expected message to be either [{nameof(GetReplicationProgressSuccess)}] or [{nameof(GetReplicationProgressFailure)}] but got [{result.GetType().FullName}]");
            }
        }

        /// <summary>
        /// Sets the written processing progress for this processor.
        /// </summary>
        public override void WriteSuccess(long write)
        {
            processingProgress = write;
            base.WriteSuccess(write);
        }

        /// <summary>
        /// Sets the read processing progress for this processor and returns it incremented by 1.
        /// </summary>
        public override long? ReadSuccess(long progress)
        {
            processingProgress = progress;
            return progress + 1L;
        }

        /// <summary>
        /// The default read timeout configured with the `eventuate.log.read-timeout` parameter. Can be overridden.
        /// </summary>
        public virtual TimeSpan ReadTimeout => settings.ReadTimeout;

        /// <summary>
        /// The default write timeout configured with the `eventuate.log.write-timeout` parameter. Can be overridden.
        /// </summary>
        public virtual TimeSpan WriteTimeout => settings.WriteTimeout;

        protected virtual DurableEvent CreateEvent(object payload, ImmutableHashSet<string> customDestinationAggregateIds) =>
            new DurableEvent(
                payload: payload,
                emitterId: this.Id,
                emitterAggregateId: this.AggregateId,
                customDestinationAggregateIds: customDestinationAggregateIds,
                vectorTimestamp: this.LastVectorTimestamp,
                processId: DurableEvent.UndefinedLogId);

        private async Task<long> WriteBatches(IEnumerable<IReadOnlyCollection<DurableEvent>> events, long previousProgress, long currentProgress)
        {
            var num = 0;
            // Ensure that a single processEvent result
            // is not partitioned across write batches.
            var batch = new List<DurableEvent>();
            var tail = new List<IReadOnlyCollection<DurableEvent>>();
            var isCollect = true;
            foreach (var e in events)
            {
                if (isCollect)
                {
                    var size = e.Count;
                    num += size;
                    if (num <= settings.WriteBatchSize || num == size)
                        batch.AddRange(e);
                    else
                    {
                        isCollect = false;
                        tail.Add(e);
                    }
                }
                else tail.Add(e);
            }

            if (batch.Count == 0 && tail.Count == 0)      return currentProgress;
            else if (batch.Count != 0 && tail.Count == 0) return await WriteBatch(batch, currentProgress);
            else
            {
                await WriteBatch(batch, previousProgress);
                return await WriteBatches(tail, previousProgress, currentProgress);
            }
        }

        private async Task<long> WriteBatch(IReadOnlyCollection<DurableEvent> events, long progress)
        {
            var metadata = ImmutableDictionary<string, ReplicationMetadata>.Empty.Add(Id, new ReplicationMetadata(progress, VectorTime.Zero));
            var result = await TargetEventLog.Ask(new ReplicationWrite(events, metadata), timeout: WriteTimeout);
            switch (result)
            {
                case ReplicationWriteSuccess _: return progress;
                case ReplicationWriteFailure f: throw f.Cause;
                default: throw new NotSupportedException($"Unexpected response message [{result.GetType().FullName}]");
            }
        }
    }

    /// <summary>
    /// An <see cref="EventsourcedProcessor"/> that supports stateful event processing. In-memory state created from source
    /// events is recovered during event replay, either starting from scratch or from a previously saved snapshot.
    /// 
    /// A <see cref="StatefulProcessor"/> writes events with vector timestamps set to the processor's current vector time. In
    /// other words, a written event has a potential causal relationship to all past source events.
    /// </summary>
    /// <seealso cref="EventsourcedProcessor"/>
    public abstract class StatefulProcessor : EventsourcedProcessor, IEventsourcedVersion
    {
        internal override bool SnapshotLoaded(Snapshot snapshot, Receive behavior)
        {
            var prev = this.CurrentVersion;
            this.CurrentVersion = snapshot.CurrentTime;
            var handled = base.SnapshotLoaded(snapshot, behavior);
            if (!handled)
                this.CurrentVersion = prev;
            return handled;
        }

        protected override DurableEvent CreateEvent(object payload, ImmutableHashSet<string> customDestinationAggregateIds) =>
            this.DurableEvent(payload, customDestinationAggregateIds);

        public override long? ReadSuccess(long progress)
        {
            base.ReadSuccess(progress);
            return null;
        }
    }
}
